<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>經典小精靈 - Pac-Man (Gemini AI 版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.5);
            border: 4px solid #2196f3;
            border-radius: 8px;
        }
        canvas {
            display: block;
        }
        .ui-panel {
            margin-top: 1rem;
            text-align: center;
            max-width: 400px;
        }
        .ai-status {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
            min-height: 60px;
            margin-bottom: 10px;
            color: #00ff00;
        }
        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .d-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
        }
        .d-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }
        .loading-spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="ui-panel">
        <h1 class="text-2xl font-bold mb-2">小精靈 PAC-MAN ✨</h1>
        
        <!-- AI 狀態區 -->
        <div class="ai-status" id="ai-commentary">
            等待玩家操作以啟動 AI... ✨
        </div>

        <div class="flex justify-around text-xl mb-2">
            <div>分數: <span id="score">0</span></div>
            <div>生命: <span id="lives">3</span></div>
        </div>

        <button id="btn-ai-strategy" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-1 rounded-full text-sm mb-3 hidden">
            ✨ AI 戰鬥策略
        </button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="d-pad md:hidden">
        <div></div>
        <div class="d-btn" id="btn-up">↑</div>
        <div></div>
        <div class="d-btn" id="btn-left">←</div>
        <div class="d-btn" id="btn-down">↓</div>
        <div class="d-btn" id="btn-right">→</div>
    </div>

    <script>
        // --- Gemini API 整合 ---
        const apiKey = ""; 
        let userInteracted = false; // 追蹤玩家是否已互動

        async function callGeminiAI(prompt, systemInstruction = "") {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] }
            };

            for (let i = 0; i < 5; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        body: JSON.stringify(payload)
                    });
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || "AI 忙碌中...";
                } catch (e) {
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
            return "連線失敗";
        }

        async function playAIVoice(text) {
            // 如果使用者還沒點擊過頁面，不發送 TTS 請求（節省資源且避免報錯）
            if (!userInteracted) return;

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: `用低沉且帶點幽靈感的聲音說: ${text}` }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Charon" } } }
                }
            };

            try {
                const response = await fetch(url, { method: 'POST', body: JSON.stringify(payload) });
                const data = await response.json();
                const base64Audio = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                if (base64Audio) {
                    const audioBlob = pcmToWavBlob(base64Audio, 24000);
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    // 即使互動過，仍建議使用 catch 處理可能的意外攔截
                    audio.play().catch(e => console.warn("播放被攔截:", e));
                }
            } catch (e) { console.error("TTS Error", e); }
        }

        function pcmToWavBlob(base64, sampleRate) {
            const binary = atob(base64);
            const buffer = new ArrayBuffer(binary.length + 44);
            const view = new DataView(buffer);
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + binary.length, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, binary.length, true);
            for (let i = 0; i < binary.length; i++) view.setUint8(44 + i, binary.charCodeAt(i));
            return new Blob([buffer], { type: 'audio/wav' });
        }

        // --- 遊戲邏輯 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const aiCommentaryEl = document.getElementById('ai-commentary');
        const strategyBtn = document.getElementById('btn-ai-strategy');

        const TILE_SIZE = 20;
        const MAP_ROWS = 21;
        const MAP_COLS = 19;
        canvas.width = MAP_COLS * TILE_SIZE;
        canvas.height = MAP_ROWS * TILE_SIZE;

        let score = 0;
        let lives = 3;
        let gameOver = false;
        let lastAIScore = 0;

        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
            [1,1,1,1,0,1,2,1,1,2,1,1,2,1,0,1,1,1,1],
            [2,2,2,2,0,2,2,1,2,2,2,1,2,2,0,2,2,2,2],
            [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
            [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
            [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,3,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,3,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let currentMap = map.map(row => [...row]);

        class Pacman {
            constructor() { this.reset(); }
            reset() {
                this.x = TILE_SIZE * 9;
                this.y = TILE_SIZE * 15;
                this.dir = { x: 0, y: 0 };
                this.nextDir = { x: 0, y: 0 };
                this.speed = 2;
                this.radius = TILE_SIZE / 2 - 2;
                this.mouthOpen = 0;
                this.powerUpActive = false;
                this.powerUpTimer = 0;
            }
            draw() {
                ctx.beginPath();
                let angle = Math.atan2(this.dir.y, this.dir.x);
                let bite = Math.abs(Math.sin(this.mouthOpen)) * 0.2 * Math.PI;
                ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, this.radius, angle + bite, angle + 2 * Math.PI - bite);
                ctx.lineTo(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2);
                ctx.fillStyle = this.powerUpActive ? '#ff0000' : 'yellow';
                ctx.fill();
                ctx.closePath();
                this.mouthOpen += 0.15;
            }
            update() {
                if (this.powerUpActive) {
                    this.powerUpTimer--;
                    if (this.powerUpTimer <= 0) {
                        this.powerUpActive = false;
                        strategyBtn.classList.add('hidden');
                    }
                }

                if (this.x < -TILE_SIZE/2) this.x = canvas.width + TILE_SIZE/2;
                if (this.x > canvas.width + TILE_SIZE/2) this.x = -TILE_SIZE/2;

                if (this.canMove(this.nextDir)) this.dir = { ...this.nextDir };
                if (this.canMove(this.dir)) {
                    this.x += this.dir.x * this.speed;
                    this.y += this.dir.y * this.speed;
                }

                const gx = Math.floor((this.x + TILE_SIZE/2) / TILE_SIZE);
                const gy = Math.floor((this.y + TILE_SIZE/2) / TILE_SIZE);

                if (currentMap[gy] && currentMap[gy][gx] === 0) {
                    currentMap[gy][gx] = 2;
                    score += 10;
                    scoreEl.innerText = score;
                    checkAIConditions();
                } else if (currentMap[gy] && currentMap[gy][gx] === 3) {
                    currentMap[gy][gx] = 2;
                    score += 50;
                    scoreEl.innerText = score;
                    this.activatePowerUp();
                }
            }
            activatePowerUp() {
                this.powerUpActive = true;
                this.powerUpTimer = 600;
                strategyBtn.classList.remove('hidden');
                triggerAICommentary("小精靈吃到了超級豆子！現在反擊開始了。");
                powerUpGhosts();
            }
            canMove(dir) {
                if (dir.x === 0 && dir.y === 0) return false;
                const nextX = this.x + dir.x * this.speed;
                const nextY = this.y + dir.y * this.speed;
                if (nextX < 0 || nextX + TILE_SIZE > canvas.width) {
                    return Math.floor((this.y + TILE_SIZE/2) / TILE_SIZE) === 9;
                }
                const corners = [{x:nextX+3,y:nextY+3}, {x:nextX+TILE_SIZE-3,y:nextY+3}, {x:nextX+3,y:nextY+TILE_SIZE-3}, {x:nextX+TILE_SIZE-3,y:nextY+TILE_SIZE-3}];
                return corners.every(c => {
                    const gx = Math.floor(c.x / TILE_SIZE);
                    const gy = Math.floor(c.y / TILE_SIZE);
                    return currentMap[gy] && currentMap[gy][gx] !== 1;
                });
            }
        }

        class Ghost {
            constructor(x, y, color) {
                this.startX = x; this.startY = y; this.color = color; this.reset();
            }
            reset() {
                this.x = this.startX; this.y = this.startY;
                this.dir = { x: 1, y: 0 }; this.speed = 1.5;
                this.scared = false; this.scaredTimer = 0;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, TILE_SIZE/2 - 2, Math.PI, 0);
                ctx.lineTo(this.x + TILE_SIZE - 2, this.y + TILE_SIZE - 2);
                ctx.lineTo(this.x + 2, this.y + TILE_SIZE - 2);
                ctx.fillStyle = this.scared ? (this.scaredTimer < 120 && Math.floor(Date.now()/200)%2 ? 'white' : 'blue') : this.color;
                ctx.fill();
                ctx.closePath();
            }
            update() {
                if (this.scared) {
                    this.scaredTimer--;
                    if (this.scaredTimer <= 0) this.scared = false;
                }
                if (this.x < -TILE_SIZE/2) this.x = canvas.width + TILE_SIZE/2;
                if (this.x > canvas.width + TILE_SIZE/2) this.x = -TILE_SIZE/2;
                if (!this.canMove(this.dir) || Math.random() < 0.02) {
                    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                    const validDirs = dirs.filter(d => !(d.x===-this.dir.x && d.y===-this.dir.y) && this.canMove(d));
                    if (validDirs.length > 0) this.dir = validDirs[Math.floor(Math.random()*validDirs.length)];
                }
                this.x += this.dir.x * (this.scared ? this.speed * 0.6 : this.speed);
                this.y += this.dir.y * (this.scared ? this.speed * 0.6 : this.speed);
                if (Math.hypot(this.x - pacman.x, this.y - pacman.y) < TILE_SIZE - 5) {
                    if (this.scared) {
                        this.reset();
                        score += 200; scoreEl.innerText = score;
                        triggerAICommentary("喔！一個幽靈被吞噬了！");
                    } else handleDeath();
                }
            }
            canMove(dir) {
                const nx = this.x + dir.x * this.speed;
                const ny = this.y + dir.y * this.speed;
                if (nx < 0 || nx + TILE_SIZE > canvas.width) return Math.floor((this.y + TILE_SIZE/2) / TILE_SIZE) === 9;
                return currentMap[Math.floor((ny+TILE_SIZE/2)/TILE_SIZE)][Math.floor((nx+TILE_SIZE/2)/TILE_SIZE)] !== 1;
            }
        }

        const pacman = new Pacman();
        const ghosts = [new Ghost(180, 180, 'red'), new Ghost(160, 180, 'pink'), new Ghost(200, 180, 'cyan'), new Ghost(180, 160, 'orange')];

        function powerUpGhosts() { ghosts.forEach(g => { g.scared = true; g.scaredTimer = 600; }); }

        function handleDeath() {
            lives--; livesEl.innerText = lives;
            if (lives <= 0) {
                gameOver = true;
                triggerAICommentary("遊戲結束。你的靈魂終究屬於迷宮...", true);
                setTimeout(() => { alert('Game Over!'); location.reload(); }, 2000);
            } else {
                pacman.reset(); ghosts.forEach(g => g.reset());
                triggerAICommentary("你還有機會... 逃跑吧，小東西。");
            }
        }

        async function triggerAICommentary(context, isGameOver = false) {
            aiCommentaryEl.innerHTML = '<span class="loading-spinner"></span> AI 正在觀察...';
            const prompt = `玩家目前狀況: ${context}. 分數: ${score}, 生命: ${lives}. 請給出一句帶有幽靈風格的簡短回應。`;
            const system = "你是一位充滿黑色幽默、語氣陰森的小精靈遊戲評論員，回應請控制在 20 字以內。";
            const comment = await callGeminiAI(prompt, system);
            aiCommentaryEl.innerText = comment;
            
            // 呼叫播放語音（內部會判斷是否已互動）
            playAIVoice(comment);
        }

        function checkAIConditions() {
            if (score - lastAIScore >= 300) {
                lastAIScore = score;
                triggerAICommentary("得分速度很快嘛，但你能撐多久？");
            }
        }

        function unlockAudio() {
            if (!userInteracted) {
                userInteracted = true;
                console.log("音訊已解鎖");
                // 移除所有監聽器，因為只需要解鎖一次
                window.removeEventListener('keydown', unlockAudio);
                window.removeEventListener('mousedown', unlockAudio);
                window.removeEventListener('touchstart', unlockAudio);
            }
        }

        // 註冊各種互動事件來解鎖音訊
        window.addEventListener('keydown', unlockAudio);
        window.addEventListener('mousedown', unlockAudio);
        window.addEventListener('touchstart', unlockAudio);

        strategyBtn.onclick = async () => {
            unlockAudio(); // 確保點擊按鈕也能解鎖
            strategyBtn.disabled = true;
            strategyBtn.innerText = "✨ AI 思考中...";
            const comment = await callGeminiAI("我現在處於超級狀態，身體變紅了，可以吃幽靈！請給我一句熱血的進攻台詞！", "你是一位戰鬥導師。");
            aiCommentaryEl.innerText = comment;
            playAIVoice(comment);
            strategyBtn.innerText = "✨ AI 戰鬥策略";
            strategyBtn.disabled = false;
        };

        function drawMap() {
            for (let y = 0; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    const val = currentMap[y][x];
                    if (val === 1) { ctx.fillStyle = '#2121de'; ctx.fillRect(x*TILE_SIZE+2, y*TILE_SIZE+2, TILE_SIZE-4, TILE_SIZE-4); }
                    else if (val === 0) { ctx.fillStyle = '#ffb8ae'; ctx.beginPath(); ctx.arc(x*TILE_SIZE+10, y*TILE_SIZE+10, 2, 0, 7); ctx.fill(); }
                    else if (val === 3) { ctx.fillStyle = '#ffb8ae'; ctx.beginPath(); ctx.arc(x*TILE_SIZE+10, y*TILE_SIZE+10, 5, 0, 7); ctx.fill(); }
                }
            }
        }

        function gameLoop() {
            if (gameOver) return;
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawMap(); pacman.update(); pacman.draw(); ghosts.forEach(g => { g.update(); g.draw(); });
            if (!currentMap.some(row => row.includes(0))) {
                gameOver = true;
                triggerAICommentary("你竟然清理了整個迷宮... 但黑暗永遠都在。", true);
                setTimeout(() => { alert('You Win!'); location.reload(); }, 3000);
            }
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') pacman.nextDir = {x:0,y:-1};
            if (e.key === 'ArrowDown') pacman.nextDir = {x:0,y:1};
            if (e.key === 'ArrowLeft') pacman.nextDir = {x:-1,y:0};
            if (e.key === 'ArrowRight') pacman.nextDir = {x:1,y:0};
        });

        document.getElementById('btn-up').onclick = () => { unlockAudio(); pacman.nextDir = {x:0,y:-1}; };
        document.getElementById('btn-down').onclick = () => { unlockAudio(); pacman.nextDir = {x:0,y:1}; };
        document.getElementById('btn-left').onclick = () => { unlockAudio(); pacman.nextDir = {x:-1,y:0}; };
        document.getElementById('btn-right').onclick = () => { unlockAudio(); pacman.nextDir = {x:1,y:0}; };

        window.onload = () => {
            gameLoop();
            // 最初始的評論僅文字，直到偵測到互動
            triggerAICommentary("準備好挑戰了嗎？請按方向鍵開始。");
        };
    </script>
</body>
</html>